import { useState, useCallback, useEffect, useMemo } from 'react';
import { Sheet, InventoryItem, UpdateLog } from '@/types/inventory';
import { toast } from '@/hooks/use-toast';

export const useInventory = () => {
  const [sheets, setSheets] = useState<Sheet[]>([]);
  const [activeSheetIndex, setActiveSheetIndex] = useState(0);
  const [updateLogs, setUpdateLogs] = useState<UpdateLog[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  
  // Load data from localStorage on mount
  useEffect(() => {
    const savedSheets = localStorage.getItem('inventory_sheets');
    const savedLogs = localStorage.getItem('update_logs');
    
    if (savedSheets) {
      setSheets(JSON.parse(savedSheets));
    }
    
    if (savedLogs) {
      setUpdateLogs(JSON.parse(savedLogs));
    }
  }, []);
  
  // Save to localStorage whenever data changes
  useEffect(() => {
    if (sheets.length > 0) {
      localStorage.setItem('inventory_sheets', JSON.stringify(sheets));
    }
  }, [sheets]);
  
  useEffect(() => {
    if (updateLogs.length > 0) {
      localStorage.setItem('update_logs', JSON.stringify(updateLogs));
    }
  }, [updateLogs]);
  
  const loadSheets = useCallback((newSheets: Sheet[]) => {
    console.log('ðŸ”„ loadSheets chamado com:', newSheets);
    console.log('ðŸ“Š Total de planilhas:', newSheets.length);
    
    newSheets.forEach((sheet, index) => {
      console.log(`ðŸ“‹ Planilha ${index}: ${sheet.name} com ${sheet.items.length} itens`);
      if (sheet.items.length > 0) {
        console.log('ðŸ“¦ Primeiro item:', sheet.items[0]);
      }
    });
    
    setSheets(newSheets);
    setActiveSheetIndex(0);
    console.log('âœ… Sheets state atualizado');
  }, []);
  
  const updateItem = useCallback((itemName: string, quantity: number, operation: 'add' | 'set' = 'add') => {
    setSheets(prevSheets => {
      const newSheets = [...prevSheets];
      const activeSheet = newSheets[activeSheetIndex];
      
      if (!activeSheet) return prevSheets;
      
      // Find item by name (case-insensitive, partial match)
      const itemIndex = activeSheet.items.findIndex(item => 
        item.name.toLowerCase().includes(itemName.toLowerCase()) ||
        itemName.toLowerCase().includes(item.name.toLowerCase())
      );
      
      if (itemIndex !== -1) {
        const item = activeSheet.items[itemIndex];
        const oldQuantity = item.quantity;
        
        if (operation === 'add') {
          item.quantity += quantity;
        } else {
          item.quantity = quantity;
        }
        
        item.lastUpdated = new Date();
        item.updatedBy = 'UsuÃ¡rio';
        
        // Add to update log
        const log: UpdateLog = {
          item: item.name,
          quantidadeAlterada: operation === 'add' ? quantity : item.quantity - oldQuantity,
          novaQuantidade: item.quantity,
          usuario: 'UsuÃ¡rio',
          dataHora: new Date().toISOString(),
          // Manter compatibilidade
          id: Date.now().toString(),
          itemName: item.name,
          change: operation === 'add' ? quantity : item.quantity - oldQuantity,
          timestamp: new Date(),
          updatedBy: 'UsuÃ¡rio',
          type: operation
        };
        
        setUpdateLogs(prev => [log, ...prev].slice(0, 50)); // Keep last 50 logs
      } else {
        // Create new item if not found
        const newItem: InventoryItem = {
          id: Date.now().toString(),
          name: itemName,
          quantity: quantity,
          unit: 'un',
          category: activeSheet.name,
          lastUpdated: new Date(),
          updatedBy: 'UsuÃ¡rio'
        };
        
        activeSheet.items.push(newItem);
        
        const log: UpdateLog = {
          item: itemName,
          quantidadeAlterada: quantity,
          novaQuantidade: quantity,
          usuario: 'UsuÃ¡rio',
          dataHora: new Date().toISOString(),
          // Manter compatibilidade
          id: Date.now().toString(),
          itemName: itemName,
          change: quantity,
          timestamp: new Date(),
          updatedBy: 'UsuÃ¡rio',
          type: 'add'
        };
        
        setUpdateLogs(prev => [log, ...prev].slice(0, 50));
      }
      
      return newSheets;
    });
  }, [activeSheetIndex]);
  
  const filteredItems = useMemo(() => {
    return sheets[activeSheetIndex]?.items.filter(item =>
      item.name.toLowerCase().includes(searchQuery.toLowerCase())
    ) || [];
  }, [sheets, activeSheetIndex, searchQuery]);
  
  return {
    sheets,
    activeSheetIndex,
    setActiveSheetIndex,
    updateLogs,
    searchQuery,
    setSearchQuery,
    filteredItems,
    loadSheets,
    updateItem,
  };
};